import { NextRequest, NextResponse } from 'next/server';
import { adminAuth, adminDb } from '@/lib/firebaseAdmin';
import bcrypt from 'bcryptjs';

export async function POST(req: NextRequest) {
    try {
        const { email, password, role, department, rollNo } = await req.json();

        // Basic Validation
        if (!role || !['admin', 'manager', 'coordinator'].includes(role)) {
            return NextResponse.json({ error: 'Invalid User Role' }, { status: 400 });
        }

        if (role === 'coordinator') {
            if (!rollNo || !department) {
                return NextResponse.json({ error: 'Coordinator requires Roll No and Department' }, { status: 400 });
            }

            // Check if user already exists
            const existing = await adminDb.collection('users').where('rollNo', '==', rollNo).get();
            if (!existing.empty) {
                return NextResponse.json({ error: 'User with this Roll No already exists.' }, { status: 400 });
            }

            // Create Coordinator (DB Only)
            await adminDb.collection('users').add({
                rollNo: rollNo.toUpperCase(),
                role: 'coordinator',
                department: department,
                createdAt: new Date(),
                email: null // Coordinator login is via RollNo
            });

            return NextResponse.json({ success: true, message: 'Coordinator created successfully.' });

        } else {
            // Admin or Manager
            if (!email || !password) {
                return NextResponse.json({ error: 'Email and Password are required.' }, { status: 400 });
            }

            // Check if user already exists in DB
            const existingUser = await adminDb.collection('users').where('email', '==', email).get();
            if (!existingUser.empty) {
                return NextResponse.json({ error: 'Email already in use.' }, { status: 400 });
            }

            // Hash Password
            const salt = await bcrypt.genSalt(10);
            const hashedPassword = await bcrypt.hash(password, salt);

            // Create User ID (can be uuid or just auto-generated by firestore)
            // Let's use Firestore auto-id for simplicity, or we can generate one.
            // Using email as ID is risky if email changes, so let's let Firestore generate or use a custom ID.
            // A clean way is to let add() generate the ref.

            const newUserRef = await adminDb.collection('users').add({
                email: email,
                passwordHash: hashedPassword,
                role: role,
                department: department || null,
                createdAt: new Date()
            });

            // Update doc to include its own UID field for consistency if needed, 
            // but the ID is on the doc ref. Let's start storing uid inside too.
            await newUserRef.update({ uid: newUserRef.id });

            return NextResponse.json({ success: true, message: `${role} account created successfully.` });
        }

    } catch (error: any) {
        console.error("Create User Error Full:", JSON.stringify(error, Object.getOwnPropertyNames(error)));
        console.error("Env Check:", {
            hasProjectId: !!process.env.FIREBASE_PROJECT_ID,
            hasClientEmail: !!process.env.FIREBASE_CLIENT_EMAIL,
            hasPrivateKey: !!process.env.FIREBASE_PRIVATE_KEY
        });

        const returnError = error.code ? `${error.code}: ${error.message}` : error.message;
        return NextResponse.json({ error: returnError || 'Internal Server Error' }, { status: 500 });
    }
}
